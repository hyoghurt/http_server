/*
1	Создать сокет
2	Привязать сокет к сетевому интерфейсу
3	Прослушивать сокет, привязанный к определенному сетевому интерфейсу
4	Принимать входящие соединения
5	Реагировать на события происходящие на сокетах
_______________________________________________________________________

https://www.opennet.ru/docs/RUS/linux_base/node244.html
socket - функция используется для создания сокета

____избежать залипание порта__
setsockopt - установить флаги на сокете

bind - функция используется сервером для присваивания сокету имени.
		До выполнения функции bind (т.е. присваивания какого-либо имени,
		вид которого зависит от адресного домена ) сокет недоступен
		программам-клиентам.

listen - Функция используется сервером, чтобы информировать ОС, что он ожидает
		("слушает") запросы связи на данном сокете. Без такой функции
		всякое требование связи с этим сокетом будет отвергнуто.

accept - функция используется сервером для принятия связи на сокет.
		Сокет должен быть уже слушающим в момент вызова функции.
		Если сервер устанавливает связь с клиентом, то функция возвращает
		новый сокет-дескриптор, через который и происходит общение
		клиента с сервером. Пока устанавливается связь клиента с сервером,
		функция accept блокирует другие запросы связи с данным сервером,
		а после установления связи "прослушивание" запросов возобновляется. 

recv -	Функция служит для чтения данных из сокета
send -	Функция служит для записи данных в сокет


getsockname
inet_addr
fcntl



select
poll, epoll (epoll_create, epoll_ctl, epoll_wait)
kqueue (kqueue, kevent)

select.	И опять его роль – это совместимость с иными платформами.
		Так же не быстр, так как срабатывает (возвращает управление)
		при событии на любом из сокетов, за которыми он наблюдает.
		После такого срабатывания нужно пробежать по всем и посмотреть
		на каком из сокетов произошло событие. Обобщая: одно
		срабатывание – это пробег по всему пулу наблюдаемых сокетов.

poll.	 более быстродейственный механизм, но не расчитан на большое
		количество сокетов для наблюдения.

epoll.	(Linux системы) и kqueue (FreeBSD) – примерно одинаковые механизмы,
		но яростные поклонники FreeBSD на некоторых форумах очень горячо
		твердят, что kqueue куда могучее. Не будем разжигать священные войны…
		Эти механизмы можно считать основными при написании высоконагруженных
		серверных приложений в *nix системах. Если описать кратко их принцип
		работы и он же достоинство – они возвращают некоторый объем
		информации, относящейся только к тем сокетам, на которых что-то
		произошло и не надо бегать по всем и проверять, что и где случилось.
		Так же эти механизмы расчитаны на большее количество одновременно
		обслуживаемых подключений.

__ЭТО Для клиента
connect - функция connect используется процессом-клиентом для
		установления связи с сервером
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <cstring>
#include <cerrno>
#include <iostream>
#include <vector>
#include <unistd.h>
//#include <sys/un.h>

void print_error(const std::string& str);

int	main()
{
	//create socket___________________________________________________
	int	ls = socket(AF_INET, SOCK_STREAM, 0);
	if (ls == -1)
	    print_error("socket");

	//set flag________________________________________________________
	int	opt = 1;
	if (-1 == setsockopt(ls, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
	    print_error("setsockopt");

	//assignment name socket__________________________________________
	struct sockaddr_in  addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(8000);
	addr.sin_addr.s_addr = INADDR_ANY;
	if (0 != bind(ls, (struct sockaddr*) &addr, sizeof(addr)))
        print_error("bind");

	//start listen socket_____________________________________________
	if (-1 == listen(ls, 5))
        print_error("listen");

	//ждем получения запроса от клиента________________________________
	//socklen_t	slen = sizeof(addr);
	//int	cl_socket = accept(ls, (struct sockaddr*) &addr, &slen);
    int	cl_socket = accept(ls, NULL, NULL);
	if (cl_socket == -1)
        print_error("accept");
	//получили запрос от клиента_______________________________________

	//читаем запрос клиента____________________________________________
	char	buf[1024];
	int		result;
	result = recv(cl_socket, buf, 1024, 0);
    //if (result == -1)
    buf[result] = '\0';
	//вывод на консоль запроса_________________________________________
    //std::cout << buf << std::endl;

	//формируем ответ для клиента______________________________________
    std::string		head;
	std::string		msg;
    std::string		response;

	//тело ответа______________________________________________________
	msg = "<title>Test C++ HTTP Server</title>\n";
	msg += "<h1>Test page</h1>\n";
    msg += "<p>This is body of the test page...</p>\n";
    msg += "<h2>Request headers</h2>\n";
    msg += "<pre>";
	msg += buf;
	msg += "</pre>\n";
	msg += "<h1>GOOD</h1>\n";
    msg += "<em><small>Test C++ Http Server</small></em>\n";

	//header ответа____________________________________________________
	head = "HTTP/1.1 200 OK\r\n";
    head += "Content-Type: text/html; charset=UTF-8\r\n";
	head += "Connection: close\r\n";
	head += "Content-Length: ";
	head += std::to_string(msg.length());
	head += "\r\n\r\n";

	//итоговый ответ___________________________________________________
	response = head + msg;

	//отправляем ответ_________________________________________________
    result = send(cl_socket, response.c_str(), response.length(), 0);
    //if (result == -1)

    close (cl_socket);
    close (ls);

	return (0);
}

void print_error(const std::string& str)
{
    std::cerr << "webserver: " << str << ": " << strerror(errno) << std::endl;
    exit (1);
}
